# 메인 스레드와 Handler
`Handler`는 메인 `Looper`와 연결되어 메인 스레드에서 `Message`를 치리하는 중심 역할을 한다. `Handler`는 백그라운드 스레드에서도 특별한 용도로 사용 가능하다

## 2.1 UI 처리를 위한 메인 스레드
UI를 업데이트하는 데는 단일 스레드 모델<sup>1</sup>이 적용된다. 멀티 스레드로 UI를 업데이트하면 동일한 UI 자원을 사용할 때 교착 상태(deadlock), 경합 상태(race condition) 등 여러 문제가 발생할 수 있다. 따라서 UI 업데이트를 메인 스레드에서만 허용한다.

앱 프로세스가 시작되면서 메인 스레드가 생성된다. 컴포넌트(액티비티, 서비스, 브로드캐스트 리시버, Application)의 생명주기 메서드와 그 안의 메서드 호출은 기본적으로 메인 스레드에서 실행된다.

1. single thread model: 해당 변수나 메서드를 사용하는 시점에는 하나의 스레드만 실행된다.

### 자바 애플리케이션에서 메인 스레드
일반적인 자바 애플리케이션에서 `main()` 메서드로 실행되는 것이 바로 메인 스레드이다.

```
public class Hello {
    public static void main(String[] args) {
        System.out.print("Hello");
    }
}
```

### 안드로이드 애플리케이션에서 메인 스레드
안드로이드 프레임워크 내부 클래스인 `android.app.ActivityThread`가 애플리케이션의 메인 클래스<sup>2</sup>이고, `ActivityThread`의 `main()` 메서드가 애플리케이션의 시작 지점이다.

`ActivityThread`는 클래스명 때문에 `Thread`를 상속한 것이라고 생각할 수 있지만, 어떤 것도 상속하지 않은 클래스이다. 클래스명의 앞부분이 `Activity`라서 액티비티와 관련된 것으로 오해할 수도 있다. `ActivityThread`는 액티비티만 관련되어 있는 것도 아니고 모든 컴포넌트들이 다 관련되어 있다.

#### 코드 2-1 `ActivityThread.java`
```
public static void main(String[] args) {
    SamplingProfilerIntegration.start();
    
    CloseGuard.setEnable(false);
    
    Environment.initForCurrentUser();
    
    EventLogger.setReporter(new EventLoggingReporter());
    
    Process.setArgV0("<pre-initialized>");
    
    Looper.prepareMainLooper(); // 1.
    
    ActivityThread thread = new ActivityThread();
    thread.attach(false);
    
    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }
    
    AsyncTask.init();
    
    Looper.loop();  // 2.
    
    throw new RuntimeException("Main thread loop unexpectedly exited");
}
```

1. 메인 `Looper`를 준비한다.
2. 제일 중요한 라인으로 여기서 UI Message를 처리한다. Looper.loop() 메서드에 무한 반복문이 있기 때문에 `main()` 메서드는 프로세스가 종료될 때까지 끝나지 않는다.

## 2.2 Looper 클래스
메인 스레드의 동작을 이해하기 위해서는 `ActivityThread`의 `main()` 메서드에서 중심이 되는 `Looper`를 이해하는 것이 필요하다.

### 스레드별로 Looper 생성
`Looper`는 TLS(thread local storage)에 저장되고 꺼내어진다. `ThreadLocal<Looper>`에 `set()` 메서드로 새로운 `Looper`를 추가하고, `get()` 메서드로 `Looper`를 가져올 때 스레드별로 다른 `Looper`가 반환된다. 그리고 `Looper.prepare()`에서 스레드별로 `Looper`를 생성한다. 메인 스레드의 메인 `Looper`는 `ActivityThread`의 `main()` 메서드에서 `Looper.prepareMainLooper()`를 호출하여 생성한다. `Looper.getMainLooper()`를 사용하면 어디서든 메인 `Looper`를 가져올 수 있다.

### Looper별로 MessageQueue 가짐
`Looper`는 각각의 `MessageQueue`를 가진다. 메인 스레드에서는 이 `MessageQueue`를 통해서 UI 작업에서 경합 상태를 해결한다. 스레드별로 다른 큐를 사용할 때는, `Looper`를 대신 사용하는 게 더 단순해질 수 있다.

### Looper.loop() 메서드의 주요 코드
#### 코드 2-2 `Looper.java`
```
public static void loop() {
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(
             "No Looper; Looper.prepare() wasn't called on this thread.");
    }
    final MessageQueue queue = me.mQueue;
    for (;;) {
        Message msg = queue.next(); // 1.
        if (msg == null) {  // 2.
            return;
        }
        msg.target.dispatchMessage(msg); // 3.
        msg.recycler();
    }
}

public void quit() {
       mQueue.quit(false);
}

public void quitSafely() {
       mQueue.quit(true);
}
```

1. `MessageQueue`에서 다음 `Message`를 꺼낸다.
2. `Message`가 `null`이라면 리턴한다.
3. `Message`를 처리한다. `target`은 `Handler` 인스턴스이고 결과적으로 `Handler`의 `dispatchMessage()` 메서드가 `Message`를 처리한다.

2.에서 `MessageQueue`에서 꺼낸 `Message`가 언제 `null`이 될까? 바로 `Looper`가 종료될 때이다. `Looper`를 종료하는 메서드가 `quit(), quitSafely()`이다. 두 메서드는 구체적으로 `MessageQueue`의 `quit(boolean safe)` 메서드를 호출하고, 그 결과 1.의 `queue.next()` 에서 `null`을 리턴하고 2.에서 `for` 반복문이 종료된다.

### quit()과 quitSafely() 메서드 차이
