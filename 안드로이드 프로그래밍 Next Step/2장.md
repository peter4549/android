# 메인 스레드와 Handler
`Handler`는 메인 `Looper`와 연결되어 메인 스레드에서 `Message`를 치리하는 중심 역할을 한다. `Handler`는 백그라운드 스레드에서도 특별한 용도로 사용 가능하다

## 2.1 UI 처리를 위한 메인 스레드
UI를 업데이트하는 데는 단일 스레드 모델<sup>1</sup>이 적용된다. 멀티 스레드로 UI를 업데이트하면 동일한 UI 자원을 사용할 때 교착 상태(deadlock), 경합 상태(race condition) 등 여러 문제가 발생할 수 있다. 따라서 UI 업데이트를 메인 스레드에서만 허용한다.

앱 프로세스가 시작되면서 메인 스레드가 생성된다. 컴포넌트(액티비티, 서비스, 브로드캐스트 리시버, Application)의 생명주기 메서드와 그 안의 메서드 호출은 기본적으로 메인 스레드에서 실행된다.

> 1. single thread model: 해당 변수나 메서드를 사용하는 시점에는 하나의 스레드만 실행된다.

### 자바 애플리케이션에서 메인 스레드
일반적인 자바 애플리케이션에서 `main()` 메서드로 실행되는 것이 바로 메인 스레드이다.

```
public class Hello {
    public static void main(String[] args) {
        System.out.print("Hello");
    }
}
```

### 안드로이드 애플리케이션에서 메인 스레드
안드로이드 프레임워크 내부 클래스인 `android.app.ActivityThread`가 애플리케이션의 메인 클래스<sup>2</sup>이고, `ActivityThread`의 `main()` 메서드가 애플리케이션의 시작 지점이다.

`ActivityThread`는 클래스명 때문에 `Thread`를 상속한 것이라고 생각할 수 있지만, 어떤 것도 상속하지 않은 클래스이다. 클래스명의 앞부분이 `Activity`라서 액티비티와 관련된 것으로 오해할 수도 있다. `ActivityThread`는 액티비티만 관련되어 있는 것도 아니고 모든 컴포넌트들이 다 관련되어 있다.

> 2. 실제로는 `ZygoteInit`이 시작점이지만 `ActivityThread`가 시작점이라고 이해하면 된다.

#### 코드 2-1 ActivityThread.java
```
public static void main(String[] args) {
    SamplingProfilerIntegration.start();
    
    CloseGuard.setEnable(false);
    
    Environment.initForCurrentUser();
    
    EventLogger.setReporter(new EventLoggingReporter());
    
    Process.setArgV0("<pre-initialized>");
    
    Looper.prepareMainLooper(); // 1.
    
    ActivityThread thread = new ActivityThread();
    thread.attach(false);
    
    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }
    
    AsyncTask.init();
    
    Looper.loop();  // 2.
    
    throw new RuntimeException("Main thread loop unexpectedly exited");
}
```

1. 메인 `Looper`를 준비한다.
2. 제일 중요한 라인으로 여기서 UI Message를 처리한다. Looper.loop() 메서드에 무한 반복문이 있기 때문에 `main()` 메서드는 프로세스가 종료될 때까지 끝나지 않는다.

## 2.2 Looper 클래스
메인 스레드의 동작을 이해하기 위해서는 `ActivityThread`의 `main()` 메서드에서 중심이 되는 `Looper`를 이해하는 것이 필요하다.

### 스레드별로 Looper 생성
`Looper`는 TLS(thread local storage)에 저장되고 꺼내어진다. `ThreadLocal<Looper>`에 `set()` 메서드로 새로운 `Looper`를 추가하고, `get()` 메서드로 `Looper`를 가져올 때 스레드별로 다른 `Looper`가 반환된다. 그리고 `Looper.prepare()`에서 스레드별로 `Looper`를 생성한다. 메인 스레드의 메인 `Looper`는 `ActivityThread`의 `main()` 메서드에서 `Looper.prepareMainLooper()`를 호출하여 생성한다. `Looper.getMainLooper()`를 사용하면 어디서든 메인 `Looper`를 가져올 수 있다.

### Looper별로 MessageQueue 가짐
`Looper`는 각각의 `MessageQueue`를 가진다. 메인 스레드에서는 이 `MessageQueue`를 통해서 UI 작업에서 경합 상태를 해결한다. 스레드별로 다른 큐를 사용할 때는, `Looper`를 대신 사용하는 게 더 단순해질 수 있다.

### Looper.loop() 메서드의 주요 코드
#### 코드 2-2 Looper.java
```
public static void loop() {
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(
             "No Looper; Looper.prepare() wasn't called on this thread.");
    }
    final MessageQueue queue = me.mQueue;
    for (;;) {
        Message msg = queue.next(); // 1.
        if (msg == null) {  // 2.
            return;
        }
        msg.target.dispatchMessage(msg); // 3.
        msg.recycler();
    }
}

public void quit() {
       mQueue.quit(false);
}

public void quitSafely() {
       mQueue.quit(true);
}
```

1. `MessageQueue`에서 다음 `Message`를 꺼낸다.
2. `Message`가 `null`이라면 리턴한다.
3. `Message`를 처리한다. `target`은 `Handler` 인스턴스이고 결과적으로 `Handler`의 `dispatchMessage()` 메서드가 `Message`를 처리한다.

2.에서 `MessageQueue`에서 꺼낸 `Message`가 언제 `null`이 될까? 바로 `Looper`가 종료될 때이다. `Looper`를 종료하는 메서드가 `quit(), quitSafely()`이다. 두 메서드는 구체적으로 `MessageQueue`의 `quit(boolean safe)` 메서드를 호출하고, 그 결과 1.의 `queue.next()` 에서 `null`을 리턴하고 2.에서 `for` 반복문이 종료된다.

### quit()과 quitSafely() 메서드 차이
`quit()` 메서드는 아직 처리되지 않은 `Message`를 모두 제거한다. `quitSafely()` 메서드는 `sendMessageDelayed()` 등을 써서 실행 타임스탬프를 뒤로 미룬 지연 `Message`를 처리하는데, `quitSafely()` 메서드를 실행하는 시점에 현재 시간보다 타임스탬프가 뒤에 있는 `Message`를 제거하고 그 앞에 있는 `Message`는 계속해서 처리한다. `quitSafely()` 메서드는 젤리빈 API 레벨 18 이상에서 쓸 수 있다.

## 2.3 Message와 MessageQueue
`MessageQueue`는 `Message`를 담는 자료구조이다. `MessageQueue`의 구조는 `java.util.Queue`의 구현체 가운데서 `ArrayBlockingQueue`보다는 `LinkedBlockingQueue`에 가깝다. `ArrayBlockingQueue`는 배열에 노드를 추가하는 방식이고 `LinkedBlockingQueue`는 변수에 다음 노드에 대한 링크를 가지는 방식이다. `MessageQueue`에는 `Message`가 실행 타임스탬프순으로 삽입되고 링크로 연결되어, 실행 시간이 빠른 것부터 순차적으로 꺼내어진다.

### Message 클래스
#### 코드 2-3 Message.java
```
public final class Message implements Parcelable {
    public int what;
    
    public int arg1;
    
    public int arg2;
    
    public Object obj;
    
    public Messenger replyTo;
    
    ...
    
    /* package */long when;
    
    /* package */Bundle data;
    
    /* package */Handler target;
    
    /* package */Runnable callback;
    
    /* package */Message next;
    
    ...
    
}
```

`MessageQueue`에 들어가는 `Message`에는 퍼블릭 변수에 `int arg1`, `int arg2`, `Object obj`, `Messenger replyTo`, `int what` 5개가 있다. `Message`를 만들 때 이 변수에 값을 넣는다. android.os 패키지 아래에 `Looper`, `Message`, `MessageQueue`, `Handler`도 있는데, 이들 클래스에서 `Message`의 패키지 프라이빗 변수에 직접 접근한다. `target`이나 `callback`같은 것들이 `Handler`에서 `postXxx(), sendXxx()` 메서드를 호출할 때 `Message`에 담겨서 `MessageQueue`에 들어간다. `postXxx(), sendXxx()` 메서드에서 실행 시간(when)이 전달되고, 나중에 호출한 것이라도 타임 스탬프가 앞서면 큐 중간에 삽입된다. 이것이 삽입이 쉬운 링크 구조를 사용한 이유다.

#### obtain() 메서드를 통한 Message 생성
`Message`를 생성할 때는 오브젝트 풀(object pool)에서 가져오는 `Message.obtain()` 메서드나 `Handler`의 `obtainMessage()` 메서드 사용을 권장한다. 내부적으로 `Handler`의 `obtainMessage()`는 `Message.obtain()`을 다시 호출한다. 오브젝트 풀은 `Message`에 정적 변수로 있고(여기서도 링크로 연결됨) `Message`를 최대 50개까지 저장한다. 그리고 `Looper.loop()` 메서드에서 `Message`를 처리하고 나서 `recycleUnChecked()` 메서드를 통해 `Message`를 다시 초기화해서 재사용한다. 오브젝트 풀이 최대 개수에 도달하지 않았다면 오브젝트 풀에 `Message`를 추가한다. `new Message()`와 같이 기본 생성자로 생성해서 값을 채워도 동작에는 문제가 없어 보이지만 `Message` 처리가 끝나면 불필요하게 풀에 `Message`를 추가하면서 금방 풀의 최대 개수에 이른다. `Message`를 풀에서 가져와서(여분이 없으면 새로 생성) 풀에 돌려줘야지 따로 생성해서 풀에 돌려주면 자원이 낭비된다.<sup>3</sup>

> 3. `Handler`에서 `Message`를 처리하는 게 아니라, 값을 전달하기 위한 용도로 `Message`를 대신 사용해서 주고받는 경우에만 `Message` 기본 생성자를 사용하자.

## 2.4 Handler 클래스
`Handler`는 `Message`를 `MessageQueue`에 넣는 기능과 `MessageQueue`에서 꺼내 처리하는 기능을 함께 제공한다.

### 2.4.1 Handler 생성자
`Handler`에는 기본 생성자 외에도 `Handler.Callback`이 전달되는 생성자도 있고, `Looper`가 전달되는 생성자도 있다.

* `Handler()`
* `Handler(Handler.Callback callback)`
* `Handler(Looper looper)`
* `Handler(Looper looper, Handler.Callback.callback)`

1~3번째 생성자는 파라미터 개수가 가장 많은 4번째 생성자를 다시 호출한다. `Handler`는 `Looper`(결국 `MessageQueue`)와 연결되어 있다. 기본 생성자는 바로 생성자를 호출하는 스레드의 `Looper`를 사용하겠다는 의미이다(`Looper`는 스레드 로컬 스토리지에 들어간다). 메인 스레드에서 `Handler` 기본 생성자는 앱 프로세스가 시작할 때 `ActivityThread`에서 생성한 메인 `Looper`를 사용한다. `Handler` 기본 생성자는 UI 작업을 할 때 많이 사용된다.

#### 백그라운드 스레드에서 Handler 기본 생성자 사용하려면 Looper 필요
백그라운드 스레드에서 `Handler` 기본 생성자를 사용한다면 어떨까? 이때 Looper가 준비되어 있지 않다면 `RuntimeException`이 발생한다. `RuntimeException`의 "Can't create handler inside thread that has not called Looper. prepare"라는 메시지에 따라 문제를 해결하려면, 먼저 `Looper.prepare()`를 실행해서 해당 스레드에서 사용할 `Looper`를 준비해야 한다. 내부적으로 `prepare()` 메서드는 `MessageQueue`를 생성하는 것 외에 별다른 동작을 하지 않는다.

#### 코드 2-4 Looper 사용
```
class LooperThread extends Thread {
    public Handler mHandler;
    
    public void run() {
        Looper.prepare();
        mHandler = new Handler() {
            public void handleMessage(Message msg) { // 1.
                // 여기서 Message 처리
            }
        };
        
        Looper.loop();
    }
}
```

`LooperThread`에서 스레드를 시작하면 `Looper.loop()`에 무한 반복문이 있기 때문에 해당 스레드는 종료되지 않는다. 그리고 `mHandler`에서 `sendXxx()`, `postXxx()` 메서드를 사용하면 스레드 내에서 1.을 실행한다.

#### 호출 위치가 메인 스레드인지 확인이 쉽지 않음
개발 중에 `Looper`가 준비되지 않아서 `RuntimeException`을 만나는 경우가 있다. 백그라운드 스레드에서 `Handler` 기본 생성자를 쓴 경우이다.

메서드 호출 스택이 깊어지면 호출 위치가 메인 스레드인지 백그라운드 스레드인지 확인이 금방 안 되기도 한다. `Handler`를 메인 스레드에서 생성하는지 백그라운드 스레드에서 생성하는지 모호한 경우가 있다. 메인 스레드에서는 메인 `Looper`가 이미 있어서 문제가 되지 않지만, 백그라운드 스레드에서는 대응하는 `Looper`가 없다면 `RuntimeException`을 만나게 된다.

```
public void process(BadgeListener listener) {
    int count = ...
    listener.updateBadgeCount(count);
}
```

`process()` 메서드는 메인 스레드에서 호출할 때는 문제가 없다. 하지만 백그라운드 스레드에서 호출한다면 `CalledFromWrongThreadException`이 발생한다. 이때 `Looper`와 `Handler`의 관계를 잘 모른다면 아래처럼 작성할 수도 있다.

```
public void process(BadgeListener listener) {
    int count = ...
    new Handler().post(new Runnable() {   // 1.
    
        public void run() {
            listener.updateBadgetCount(count); // 2.
        }
        
    });
}
```

백그라운드 스레드에서 `Looper`가 연결되어 있지 않다면 1.에서 `RuntimeException`이 발생한다. 백그라운드 스레드에서 `Looper`를 생성해도 2.는 UI를 업데이트하는 작업이기 때문에 이번에는 `CalledFromWrongThreadException`이 발생한다. 메인 스레드에서만 UI를 업데이트할 수 있는데, 바로 메인 `Looper`와 연결된 `Handler`가 필요하다. 이때 `Handler`의 세 번째 생성자인 `Handler(Looper looper)`를 사용하면 된다.

```
public void process(BadgeListener listener) {
    int count = ...
    new Handler(Looper.getMainLooper()).post(new Runnable() {
        
        public void run() {
            listener.updateBadgeCount(count);
        }
        
    });
}
```

`Handler` 생성자에 `Looper.getMainLooper()`를 전달하면, 메인 `Looper`의 `MessageQueue`에서 `Runnable Message`를 처리한다.

### 2.4.2 Handler 동작
`Handler`는 `Message`를 `MessageQueue`에 보내는 것과 `Message`를 처리하는 기능을 함께 제공한다. `post()`, `postAtTime()`, `postDelayed()` 메서드를 통해서 `Runnable` 객체도 전달되는데, `Runnable`도 내부적으로 `Message`에 포함되는 값이다.

`Handler`에서 `Message`를 보내는 메서드 목록

|                  | `send`                                                                                                        | `post`                                                                                                   |
|------------------|---------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------|
| 기본          | `sendEmptyMessage(int what)`<br>`sendMessage(Message msg)`                                                    | `post(Runnable r)`                                                                                       |
| `-Delayed`       | `sendEmptyMessageDelayed(int what, long delayMillis)`<br>`sendMessageDelayed(Message msg, long delayMillies)` | `postDelayed(Runnable r, long delayMillis)`                                                              |
| `-AtTime`        | `sendEmptyMessageAtTime(int what, long uptimeMillis)`<br>`sendMessageAtTime(Message msg, long uptimeMillis)`  | `postAtTime(Runnable r, Object token, long uptimeMillis)`<br>`postAtTime(Runnable r, long uptimeMillis)` |
| `AtFrontOfQueue` | `sendMessageAtFrontOfQueue(Message msg)`                                                                      | `postAtFrontOfQueue(Runnable r)`                                                                         |                                                     | `postAtFrontOfQueue(Runnable r)`                                                                      |

* `sendEmptyMessage()`, `sendEmptyMessageDelayed()`, `sendEmptyMessageAtTime()` 메서드는 `Message`의 `what` 값만을 전달한다.
* `-Delayed()`로 끝나는 메서드는 내부적으로 `-AtTime()` 메서드를 호출한다. 현재 시간 `uptimeMillis`에 `delayedMillis`를 더한 값이 `uptimeMillis` 파라미터에 들어간다.
* `sendMessageAtFrontOfQueue()`나 `postAtFrontOfQueue()` 메서드는 특별한 상황이 아니면 쓰지 말라는 가이드가 있다. 권한 문제나 심각한 서버 문제처럼, 앱을 더 이상 쓸 수 없는 특별한 때가 아니면 사용할 일이 없다. 남용하면 안되는 메서드이다.

#### dispatchMessage() 메서드
#### 코드 2-5 Handler.java
```
public void dispatchMessage(Message msg) {
    if (msg.callback != null) { // 1.
        handleCallback(msg);
    } else {
        if (mCallback != null) {
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        handleMessage(msg);
    }
}

private static void handleCallback(Message message) {
    message.callback.run();
}
```

1. `callback Runnable`이 있다면 그것을 실행하고 아니면 `handleMessage()`를 호출한다.

dispatchMessage()는 퍼블릭 메서드이다. `sendXxx()`나 `postXxx()`를 쓰지 않고 `dispatchMessage()` 메서드를 직접 호출하기도 하는데, 이때는 `MessageQueue`를 거치지 않고 `Message`를 처리한다.

### 2.4.3 Handler 용도
`Handler`는 일반적으로 UI 갱신을 위해 사용된다.

#### 백그라운드 스레드에서 UI 업데이트
백그라운드 스레드에서 네트워크나 DB 작업 등을 하는 도중에 UI를 업데이트한다. `AsyncTask`에서도 내부적으로 `Handler`를 이용해서 `onPostExecute()` 메서드를 실행해서 UI를 업데이트한다.

#### 메인 스레드에서 다음 작업 예약
UI 작업 중에 다음 UI 갱신 작업을 `MessageQueue`에 넣어 예약한다. 작업 예약이 필요한 경우가 있는데, 예를 들어 `Activity`의 `onCreate()` 메서드에서 하지 못하는 일들이 있다. 소프트 키보드를 띄우는 것이나, `ListView`의 `setSelection()` 메서드를 호출하는 작업은 `onCreate()` 메서드에서는 잘 동작하지 않는다. 이때 `Handler`에 `Message`를 보내면 현재 작업이 끝난 이후의 다음 타이밍에 `Message`를 처리한다.

#### 반복 UI 갱신
반복해서 UI를 갱신한다. `DigitalClock`이나 `TextClock` 같은 위젯도 `Handler`를 이용해서 현재 시간을 갱신해서 보여준다.

#### 코드 2-6 반복 UI 갱신 패턴
```
private static final int DELAY_TIME = 2000;

private Runnable updateTimeTask = new Runnable() {

    @Override
    public void run() {
        systemInfo.setText(monitorService.getSystemInfo());
        handler.postDelayed(this, DELAY_TIME); // 1.
    }
};

public void onClickButton(View view) {
    handler.post(updateTimeTask);
}
```

UI 갱신이 끝나고 1.에서 `postDelayed()`에 `Runnable` 자체를 전달해서 계속 반복한다.

#### 시간 제한
시간을 제한할 때 사용한다. 안드로이드에서 내부적으로 ANR을 판단할 때도 사용하는 방법이다. 아래 코드는 개발자 가이드에 있는 것인데, 블루투스 LE 디바이스를 스캔하는 시간을 제한한다.

#### 코드 2-7 블루투스 LE 스캔 시간 제한
```
private static final long SCAN_PERIOD = 10000;

private void scanLeDevice(final boolean enable) {
    if (enable) {
        mHandler.postDelayed(new Runnable() { // 1.
            
            @Override
            public void run() {
                mScanning = false;
                mBluetoothAdapter.stopLeScan(mLeScanCallback);
            }
            
        }, SCAN_PERIOD);
        
        mScanning = true;
        mBluetoothAdapter.startLeScan(mLeScanCallback); // 2.
    } else {
        mScanning = false;
        mBluetoothAdapter.stopLeScan(mLeScanCallback);
    }
    ...
}
```

#### 코드 2-8 백 키를 두 번 이상 연속해서 누를 때만 액티비티 종료
```
private boolean isBackPressedOnce = false; // 1.

@Override
public void onBackPressed() {
    if (isBackPressedOnce) { // 2.
        super.onBackPressed();
    } else {
        Toast.makeText(this, R.string.backpressed_message, Toast.LENGTH_SHORT).show(); // 3.
        isBackPressedOnce = true; // 4.
        timerHandler.postDelayed(timerTask, 5000);  // 5.
    }
}

private final Runnable timerTask = new Runnable() { // 6.

    @Override
    public void run() {
        isBackPressedOnce = false;
    }
};
```

## 2.6 ANR
**"Application Not Responding"(ANR)**
어느 동작에서 메인 스레드를 오랫동안 점유하고 있다는 의미이다. 이 메시지를 통해 메인 스레드 점유가 끝날 때까지 대기할 것인지 프로세스를 종료할 것인지 사용자에게 묻는 과정을 거친다. 아무리 앱을 잘 만들어도 단말 상태가 좋지 않으면 ANR이 발생할 수 있기 때문에 이를 완벽하게 피할 수는 없다. 안드로이드 프레임워크에서 ANR 관련한 내용은 `com.android.server.am.ActivityManagerService`에서 확인할 수 있다(`ActivityManagerService`는 `system_server` 프로세스에서 실행된다).

### 2.6.1 ANR 타임아웃
ANR 타임아웃을 프레임워크 소스에서 확인해 보자. 젤리빈 이상에 적용된 내용을 보자.

```
// How long we allow a receiver to run before giving up on it.
static final int BROADCAST_FG_TIMEOUT = 10 * 1000;
static final int BROADCAST_BG_TIMEOUT = 60 * 1000;

// How long we wait until we timeout on key dispatching.
static final int KEY_DISPATCHING_TIMEOUT = 5 * 1000; // 1.
```

> **안드로이드 프레임워크 내부에서 쓰이는 Handler**
> 안드로이드 프레임워크에서도 내부적으로 `Handler`를 많이 사용한다. 메인 스레드에서 실행해야 하는 작업들이, `Handler`를 사용해서 메인 `Looper`의 `MessageQueue`를 거쳐서 순차적으로 실행된다.

1.에서 InputDispatching(소스를 보다 보면 KeyDispatching, InputDispatching 용어가 혼재되어 있는데 InputDispatching이 키 이벤트와 터치 이벤트를 포함한 것이라서 더 적절하다) 타임아웃은 `ActivityManagerService`뿐만 아니라, 네이티브 코드에도 동일한 값이 상수로 되어있다.

ICS 이하에서는 코드가 좀 다르다.

```
// How long we allow a receiver to run before giving up on it.
static final int BROADCAST_TIMEOUT = 10 * 1000;

// How long we wait for a service to finish executing.
static final int SERVICE_TIMEOUT = 20 * 1000;

// How long we wait until we timeout on key dispatching.
static final int KEY_DISPATCHING_TIMEOUT = 5 * 1000;
```

젤리빈부터 생긴 차이는 2가지가 보인다.

1. SERVICE_TIMEOUT이 보이지 않는다. 그렇다고 서비스의 타임아웃이 사라진 것은 아니다. 클래스가 분리되면서 `com.android.server.am.ActiveServices`로 위치가 변경되었다.
2. 브로드캐스트 리시버 타임아웃이 포그라운드와 백그라운드 2단계로 바뀌었다. 기존에는 ANR이 10초면 발생하였지만 이제는 특별히 명시하지 않으면 1분(백그라운드)이면 타임아웃이 된다. 포그라운드로 명시하는 방법은 `sendBroadcast()`에 전달되는 `Intent`에 `Intent.FLAG_RECEIVER_FOREGROUND` 플래그를 추가하는 것이다. `ActivityManagerService`에는 포그라운드/백그라운드 용도의 `BroadcastQueue`가 각각 있는데, 큐에 쌓인 순서에 관계없이 포그라운드 용도의 `BroadcastQueue`를 먼저 처리한다.

세부적으로 구분하지 않는다면 타임아웃 케이스에는 크게 3가지가 있다. 브로드캐스트 리시버와 서비스, 그리고 InputDispatching(해당 케이스가 발생하는 것은 액티비티이므로 액티비티의 타임아웃으로 보기도 함)이다.
