# 백그라운드 스레드
## 3.1 HandlerThread 클래스
`HandlerThread`는 `Thread`를 상속하고, 내부에서 `Looper.prepare()`와 `Looper.loop()`를 실행하는 `Looper` 스레드이다. `HandlerThread`는 `Looper`를 가진 스레드이면서 `Handler`에서 사용하기 위한 스레드라고 보는 게 맞다. `Handler`는 `HandlerThread`에서 만든 `Looper`에 연결하는데, 2.4.1절에서 설명한 `Handler`의 세 번째 생성자를 사용한다.

코드 2-4를 다시 보자. `Looper.loop()`는 무한 반복문을 포함하기 때문에 계속 리턴되지 않는다. `Looper.myLooper().quit()` 메서드를 실행할 수 있는 위치가 `loop()` 다음 라인에서는 할 수 없기 때문에, 멤버 변수로 `Looper`를 가지고 다른 스레드에서 `Looper.quit()`을 실행해야 한다.

`Looper`를 사용하는 방법은 `Looper.loop()`만 돌고 있는 백그라운드 스레드를 만들고, 이 스레드는 명시적으로 종료하기 전까지는 계속해서 살아있게 한다. 그리고 `Message`는 이 `Looper` 스레드에서 계속 처리된다. `Handler`를 `Looper`에 연결하는 방식에는 2가지가 있는데, 코드 2-4처럼 `Handler`를 스레드 안에 두고 사용하는 방식이 있고, 스레드에서 `Looper`를 시작하고 스레드 외부에서 `Handler`를 생성하는 방식이 있다. 두 번째 방식을 미리 만든 것이 `HandlerThread`이다. `HandlerThread`는 내부적으로 `prepare()`, `loop()`를 실행하는 것 외에 별다른 내용은 없다.

#### 코드 3-1 HandlerThread 사용 방법
```
private HandlerThread handlerThread;

public Processor() {
    handlerThread = new HandlerThread("Message Thread");
    handlerThread.start();
}

public void process() {
    ...
    new Handler(handlerThread.getLooper()).post(new Runnable() {  // 1
    
        @Override
        public void run() {
            ...
        }
    });
}
```

1 `Handler`의 세 번째 생성자에 `HandlerThread`의 `Looper`를 전달한다. 이후에는 이 `Handler`에서 보낸 `Message`가 `HandlerThread`에서 생성한 스레드에서 처리된다.

#### HandlerThread 프레임워크 
#### 코드 3-2 HandlerThread.java
```
public class HandlerThread extends Thread {

    Looper mLooper;
    
    @Override
    public void run() {
        Looper.prepare();
        synchronized (this) {
            mLooper = Looper.myLooper(); // **1**
            notifyAll(); // 2
        }
        Looper.loop();
    }

    public Looper getLooper() {
        if (!isAlive()) { // 3
            return null;
        }
        synchronized (this) {
            while (isAlive() && mLooper == null) { // 4
                try {
                    wait(); // 5
                } catch (InterruptedException e) {
                }
            }
        }
        return mLooper;
    }
    
    public boolean quit() {
        Looper looper = getLooper();
        if (looper != null) {
            looper.quit();
            return true;
        }
        return false;
    }
}
```

`run()` 메서드에서 `Looper.prepare()`와 `Looper.loop()`를 실행하면 될 것 같지만 추가적인 작업이 더 있다. 1에서 `mLooper`에 `Looper.myLooper()`를 대입하는 것이다. 그런데 `getLooper()` 메서드나 `quit()` 메서드에서 `mLooper`를 직접적으로 사용하지 않는다. 다시 말해서 `getLooper()`에서 바로 `return mLooper`와 같이 단 한 줄로 끝나지 않는다. `quit()`에서도 `mLooper`는 사용되지 않고 `getLooper()` 메서드를 거친다.

`getLooper()` 메서드는 공개 메서드로 외부에서도 사용된다. 코드 3-1을 보면 `Handler` 생성자에 전달돼서 `Handler`에 `HandlerThread`의 `Looper`를 연결시킨다.

3 `Thread`를 상속한 `HandlerThread`에서 `start()`를 호출했는지 체크한다. `isAlive()`는 스레드가 `start()` 메서드로 시작되고 아직 종료되지 않았을 때 `true`를 리턴한다. `HandlerThread`가 사용할 때 `start()`를 빠뜨리는 실수를 하기 쉬운데 `getLooper()`를 호출하기 전에 반드시 `start()`를 호출해야 한다.
