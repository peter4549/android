# 백그라운드 스레드
## 3.1 HandlerThread 클래스
`HandlerThread`는 `Thread`를 상속하고, 내부에서 `Looper.prepare()`와 `Looper.loop()`를 실행하는 `Looper` 스레드이다. `HandlerThread`는 `Looper`를 가진 스레드이면서 `Handler`에서 사용하기 위한 스레드라고 보는 게 맞다. `Handler`는 `HandlerThread`에서 만든 `Looper`에 연결하는데, 2.4.1절에서 설명한 `Handler`의 세 번째 생성자를 사용한다.

코드 2-4를 다시 보자. `Looper.loop()`는 무한 반복문을 포함하기 때문에 계속 리턴되지 않는다. `Looper.myLooper().quit()` 메서드를 실행할 수 있는 위치가 `loop()` 다음 라인에서는 할 수 없기 때문에, 멤버 변수로 `Looper`를 가지고 다른 스레드에서 `Looper.quit()`을 실행해야 한다.

`Looper`를 사용하는 방법은 `Looper.loop()`만 돌고 있는 백그라운드 스레드를 만들고, 이 스레드는 명시적으로 종료하기 전까지는 계속해서 살아있게 한다. 그리고 `Message`는 이 `Looper` 스레드에서 계속 처리된다. `Handler`를 `Looper`에 연결하는 방식에는 2가지가 있는데, 코드 2-4처럼 `Handler`를 스레드 안에 두고 사용하는 방식이 있고, 스레드에서 `Looper`를 시작하고 스레드 외부에서 `Handler`를 생성하는 방식이 있다. 두 번째 방식을 미리 만든 것이 `HandlerThread`이다. `HandlerThread`는 내부적으로 `prepare()`, `loop()`를 실행하는 것 외에 별다른 내용은 없다.

#### 코드 3-1 HandlerThread 사용 방법
```
private HandlerThread handlerThread;

public Processor() {
    handlerThread = new HandlerThread("Message Thread");
    handlerThread.start();
}

public void process() {
    ...
    new Handler(handlerThread.getLooper()).post(new Runnable() {  // 1.
    
        @Override
        public void run() {
            ...
        }
    });
}
```

1. `Handler`의 세 번째 생성자에 `HandlerThread`의 `Looper`를 전달한다. 이후에는 이 `Handler`에서 보낸 `Message`가 `HandlerThread`에서 생성한 스레드에서 처리된다.

#### HandlerThread 프레임워크 
